\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\usepackage{minted}

\usepackage{hyperref}

%opening
\title{SSR-viz - a toolbox to detect and visualize protein
subfamily specific residues}
\author{Paul Zierep}

\begin{document}

\maketitle

\begin{abstract}


\end{abstract}

Homologous proteins can be classified into protein families. The members of a family share a similar structure and sequence. Despite their inherent
similarity, individual members of the same family can adopt very specific functions, leading to a further division into subfamilies. These functional
differences can often be assigned to specific residues. This information can be used for various applications, such as function-based subfamily
classification, rational site-directed mutagenesis and general elucidation of mechanisms of action. Here we introduce a novel user-friendly open-source
software which allows for the identification and visualization of these residues.

\pagebreak
\tableofcontents
\pagebreak


\section{Installation}

\subsection{Using Pip}

SSR-viz in implemented as a standalone GUI framework. It is entirely 
written in Python 3. The program was successfully installed on
Ubuntu 14.04/16.04/18.04 and Windows 10/8. It can be installed via PIP - the official python repository. 
To install SSR-viz open a terminal an type: 

\begin{minted}{bash}
pip3 install ssrviz
\end{minted}

Some packages, especially \textbf{wxPython} 
which are normally automatically installed
by PIP can make problems, as they are using system dependencies, which can 
lead to errors when missing. 
Good advice to install wxPython can be 
found at: \url{https://wxpython.org/pages/downloads/index.html}.
They also supply custom builds which work on Ubuntu 16.04 and various other
Linux systems.

Nevertheless wxPython needs some system dependencies on Linux:
They can be easily installed for Ubuntu 16.04:

\begin{minted}{bash}
sudo apt-get install libwebkitgtk-dev libgtk2.0-dev libsdl1.2-dev \
freeglut3 freeglut3-dev libnotify-dev libgstreamerd-3-dev \
libgl1-mesa-glx libglu1-mesa libgl1-mesa-dev libglu1-mesa-dev \
libgconf2-dev libsdl1.2-dev zlib1g-dev libjpeg62-dev
\end{minted}

In some cases the \textbf{matplotlib} might also need some Help with \textbf{tkinter}.

\begin{minted}{bash}
sudo apt-get install python3-tk
\end{minted}

Installation via Pip for Windows should work without additional installations.

\subsection{Clone from GitHub}

It can also be cloned from GitHub \url{https://github.com/PhaBiFreiburg/SSR-viz}.
But then the dependencies need to be installed manually, 
see: \\
SSR-viz/documenation/requirements.txt

\subsection{Standalone executables (easy but big)}

Additionally we implemented standalone 
executables for Windows (tested on windows 10) and Linux (tested on Ubunt 16.04).
These a much bigger then the pure python module, but ship everything needed out of
the Box. 

\subsection{Mafft}

The only external tool needed is mafft, an excellent alignment tool which is 
required to map protein structure indices to the alignment. SSR-viz runs
without mafft, but for the \textbf{Add\_pdb} tool the mafft executable needs 
to be assigned (see section~\ref{add_p}).
Dont't worry mafft is easy to install on all systems:

\url{https://mafft.cbrc.jp/alignment/software/}

\section{Getting started}

The SSR-viz algorithm is based on a multiple sequence alignment (MSA) file in 
FASTA format, which can be generated with various tools, such as Clustalo 
and Mafft or with a Webserver such as 
\href{https://zeus.cmm.msu.ru/#scenario=2}{Mustguseal} or 
\href{http://prodata.swmed.edu/promals3d/promals3d.php}{PROMALS3D}.

The topic of sequence alignment is beyond the scope of this manual.  
Nevertheless one should keep in mind that 
the quality of the alignment is crucial for the detection algorithm.
(Is is difficult to interpret the importance of a position, which has
more gaps then amino acids.)

Please provide the alignment in FASTA format, most tools allow this as format as
an output option.

The first step is the classification of the sequences into subfamilies.
This is undoubtedly the most difficult part, as it often requires 
to identify the specific functionality based on scientific literature
or even undertake experimental validation. Dedicated databases such as 
\href{https://www.uniprot.org/}{UniProt} and \href{http://www.pantherdb.org/downloads/index.jsp}{PANTHER} 
can help to identify 
detailed protein functionality. 

Even though there are various tools available that can cluster protein sequences, 
these clustering methods always apply some kind of similarity scoring,
which leads in most cases to a clustering based on evolutionary relationship 
rather then functional similarity. 
This is demonstrated on an example in section~\ref{example}.

Ones you collected the class information of your sequences you can add
them to your alignment. The \textbf{CSV\_Builder} tool allows to creates 
a comma separated value (CSV) file which can be used to add the class label to the sequences
(see section~\ref{csv_b}).

An alignment and the CSV file is everything needed to 
detect subfamily specific residues in the sequences. 
The \textbf{SSR\_plot} tool handles the actual execution of the detection
algorithm, the output can be a mathplotlib \todo{cite} style plot (see section~\ref{ssr_p})
as pdf, a Javlview annotation file (which can show the results together with the 
alignment) as well as a 'stats.csv' file which summarizes the SSRs.

In most cases it is desired to observe the SSRs in a structural context.
Therefore, we also developed a tool \textbf{Add\_pdb} which allows
to map the indices of a protein structure file (*.pdb) to the indices of the 
alignment in the 'stats.csv' file (see section~\ref{add_p}).

An overview chart which explains the setup of the three tools is shown in
the poster (\todo{add link}).

\section{CSV builder} \label{csv_b}

The \textbf{CSV\_Builder} handles the input and takes care, 
that the alignment and CSV class label file have the right formating.

The mapping scheme is shown in Fig.~\todo{fig}.

\subsection{Arguments}

\begin{description}

\item[\texttt{Input sequence alignment file}] \hfill \\
 
The alignment file with the sequences of the family.
The deisred format is in FASTA fromat (clustalo), see section~\ref{example}
for an example.

\item[\texttt{Inplace FASTA conversion / Temporary alignment file name}] \hfill \\
 
The \textbf{CSV\_Builder} routine will remove duplicates from the 
alignment, as multiple identical sequences will overestimate the importance
of this subfamily. The alignment can be converted inplace, meaning
the original alignment is overwritten or a new alignment can be 
created.

\item[\texttt{Regex extraction of the class label}] \hfill \\
 
The normal \textbf{CSV\_Builder} routine will create a CSV file,
with an empty column for the class labels. Which must be manually 
filled.
In some cases the class label is part of the sequence names,
this labels can be extracted using regular expressions (regex) patterns.
The entire scope of regex is to big for this manual, but the set of
examples in the appendix~\ref{appendix} should help to get started. There are various 
tools available which can be used to test regex before usage, most text editors 
support regex as a search option. You can 
for example load the alignment file into sublime or notepad, then
search with regex and if the pattern is correct, it should only highlight 
the desired class label. An example is shown in appendix~\ref{appendix}.

\item[\texttt{Output}] \hfill \\

The name of the CSV file, by default it will be created in the same folder as
the sequence file.

\item[\texttt{Delete}] \hfill \\

Allows to overwrite existing CSV files.

\end{description}


\section{SSR plot} \label{ssr_p}

The 

\subsection{Algorithm}

\subsection{Arguments}

\subsection{Output}

\section{Add pdb} \label{add_p}

\subsection{Arguments}

\section{Example} \label{example}

\section{Appendix} \label{appendix}

\subsection{Regex examples}

% Example 1
% 
% > sequence1\_spec_ATP
% > sequence2\_spec_ADP
% > sequence3\_spec_ADP
% > sequence4\_spec_ATP
% > sequence5\_spec_ATP
% 
% Possible Regex: ''\_([ATDP]+)\$'' 
% 
% Example 2
% 
% > sequence1\#1
% > sequence2\#3
% > sequence3\#1
% > sequence4\#3
% > sequence5\#4
% 
% Possible Regex: ''\#([1-9])\$'' 
% 
% Example 1
% 
% > class:mm_sequence1
% > class:mom_sequence2
% > class:mm_sequence3
% > class:mm_sequence4
% > class:mal_sequence5
% 
% Possible Regex: ''class:([a-z]*)_'' 


\end{document}
