\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\usepackage{minted}

\usepackage{hyperref}

%opening
\title{SSR-viz - a toolbox to detect and visualize protein
subfamily specific residues}
\author{Paul Zierep}

\begin{document}

\maketitle

\begin{abstract}


\end{abstract}
Protein families can often be further divide into 
functional diverse subfamilies. Each subfamily posses very specific functions
which distinguishes them from each other. Examples are substrate specificity,
protein-protein interaction or different reaction types. In many cases these functions are
based on a limited set of residues. Therefore, to understand the protein diversity,
the identification of those residues is crucial.
In order to support researchers in this task we developed a toolbox
which allows to detect and visualize those residues, based on a multiple sequence 
alignment of proteins with experimental validated functionality.

\pagebreak
\tableofcontents
\pagebreak


\section{Installation}

SSR-viz in implemented as a standalone GUI framework. It is entirely 
written in Python 3. The program was successfully installed on
Ubuntu 14.04/16.04 /18.04; Windows 10/8 and MacOS Sierra. But the 
installation can be 


It can be installed via PIP - the official python repository, using the 

\texttt{pip3 install ssrviz}

Or cloned from GitHub \todo{}


and therefore the easiest way to obtain it is trough 
PIP - the official python repository. For Debian bases systems and Ubuntu:

\begin{minted}{bash}
pip3 install ssrviz
\end{minted}

Should be enough ... in general. Some packages, especially \textbf{wxPython} 
which are normally automatically installed
by PIP can make problems, as they are using system dependent, which can 
lead to errors when the dependencys are missing. 

Good advice to install wxPython can be 
found at: \url{https://wxpython.org/pages/downloads/index.html}.
They also supply custom builds which work on Ubuntu 16.04 and various other
Linux systems.

Nevertheless wxPython needs some system dependencys on Linux:
They can be easily installed for Ubuntu 16.04 the packages would be:

\begin{minted}{bash}
sudo apt-get install libwebkitgtk-dev libgtk2.0-dev libsdl1.2-dev \
freeglut3 freeglut3-dev libnotify-dev libgstreamerd-3-dev \
libgl1-mesa-glx libglu1-mesa libgl1-mesa-dev libglu1-mesa-dev \
libgconf2-dev libsdl1.2-dev zlib1g-dev libjpeg62-dev
\end{minted}

In some cases the \textbf{matplotlib} might also need some Help with \textbf{tkinter}.

\begin{minted}{bash}
sudo apt-get install python3-tk
\end{minted}

Additionally we implemented standalone 
executables for Windows (tested on windows 10) and Linux (tested on Ubunt 16.04).
These a much bigger then the pure python module, but ship everything needed out of
the Box. 

The only external tool needed is mafft, an excellent alignment tool which is 
required to map protein structure indices to the alignment. SSR-viz runs
without mafft, but for the \textbf{Add\_pdb} tool the mafft executable needs 
to be assigned (see section~\ref{add_p}).

Dnt't worry mafft is easy to install:

\url{https://mafft.cbrc.jp/alignment/software/}


\section{Getting started}

The SSR-viz algorithm is based on a multiple sequence alignment (MSA) file in 
FASTA format, which can be generated with various tools, such as Clustalo 
and Mafft or with a Webserver such as (\todo{cite and add server}). 

The topic of sequence alignment is beyond the scope of this manual.  
Nevertheless one should keep in mind that 
the quality of the alignment is crucial for the detection algorithm.
(Is is difficult to interpret the importance of a position, which has
more gaps then amino acids.)

The first step is the classification of the sequences into subfamilies.
This is undoubtedly the most difficult part, as it often requires 
to identify the specific functionality based on scientific literature
or even undertake experimental validation. Dedicated databases such as 
\todo{add some DB} can help to identify 
detailed protein functionality. 

Even though there are various tools available that can cluster protein sequences, 
these clustering methods always apply some kind of similarity scoring,
which leads in most cases to a clustering based on evolutionary relationship 
rather then functional similarity. 
This is demonstrated on an example in section~\ref{example}.

Ones you collected the class information of your sequences you can add
them to your alignment. The \textbf{CSV\_Builder} tool allows to creates 
a comma separated value (CSV) file which can be used to add the class label to the sequences
(see section~\ref{csv_b}).

An alignment and the CSV file is everything thats needed to 
detect subfamily specific residues in the sequences. 
The \textbf{SSR\_plot} tool handles the actual execution of the detection
algorithm, the output can be a mathplotlib \todo{cite} style plot (see section~\ref{ssr_p})
as pdf, a Javlview annotation file (which can show the results together with the 
alignment) as well as a 'stats.csv' file which summarizes the SSRs.

In many cases it is desired to observe the SSRs inside a protein 
structure (if available). Therefore, we also developed a tool \textbf{Add\_pdb} which allows
to map the indices of a protein structure file (*.pdb) to the indices of the 
alignment in the ''stats.csv' file (see section~\ref{add_p})

An overview chart which explains the setup of the three tools is shown in
figure~\todo{figure}

\section{CSV builder} \label{csv_b}

The \textbf{CSV\_Builder} handles the input and takes care, 
that the alignment and CSV class label file have the right formating.

The mapping scheme is shown in Fig.~\todo{fig}.

\subsection{Arguments}

\begin{description}

\item[\texttt{Input sequence alignment file}] \hfill \\
 
The alignment file with the sequences of the family.
The deisred format is in FASTA fromat (clustalo), see section~\ref{example}
for an example.

\item[\texttt{Inplace FASTA conversion / Temporary alignment file name}] \hfill \\
 
The \textbf{CSV\_Builder} routine will remove duplicates from the 
alignment, as multiple identical sequences will overestimate the importance
of this subfamily. The alignment can be converted inplace, meaning
the original alignment is overwritten or a new alignment can be 
created.

\item[\texttt{Regex extraction of the class label}] \hfill \\
 
The normal \textbf{CSV\_Builder} routine will create a CSV file,
with an empty column for the class labels. Which must be manually 
filled.
In some cases the class label is part of the sequence names,
this labels can be extracted using regular expressions (regex) patterns.
The entire scope of regex is to big for this manual, but the set of
examples in the appendix~\ref{appendix} should help to get started. There are various 
tools available which can be used to test regex before usage, most text editors 
support regex as a search option. You can 
for example load the alignment file into sublime or notepad, then
search with regex and if the pattern is correct, it should only highlight 
the desired class label. An example is shown in appendix~\ref{appendix}.

\item[\texttt{Output}] \hfill \\

The name of the CSV file, by default it will be created in the same folder as
the sequence file.

\item[\texttt{Delete}] \hfill \\

Allows to overwrite existing CSV files.

\end{description}


\section{SSR plot} \label{ssr_p}

The 

\subsection{Algorithm}

\subsection{Arguments}

\subsection{Output}

\section{Add pdb} \label{add_p}

\subsection{Arguments}

\section{Example} \label{example}

\section{Appendix} \label{appendix}

\subsection{Regex examples}

% Example 1
% 
% > sequence1\_spec_ATP
% > sequence2\_spec_ADP
% > sequence3\_spec_ADP
% > sequence4\_spec_ATP
% > sequence5\_spec_ATP
% 
% Possible Regex: ''\_([ATDP]+)\$'' 
% 
% Example 2
% 
% > sequence1\#1
% > sequence2\#3
% > sequence3\#1
% > sequence4\#3
% > sequence5\#4
% 
% Possible Regex: ''\#([1-9])\$'' 
% 
% Example 1
% 
% > class:mm_sequence1
% > class:mom_sequence2
% > class:mm_sequence3
% > class:mm_sequence4
% > class:mal_sequence5
% 
% Possible Regex: ''class:([a-z]*)_'' 


\end{document}
